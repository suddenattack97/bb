<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ê²€ì¦</title>

  <!-- Lightweight Charts v4 (standalone) -->
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Malgun Gothic', 'Segoe UI', sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 18px;
    }

    /* â”€â”€ í—¤ë” íŒ¨ë„ â”€â”€ */
    #header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 18px;
    }
    #header h1 { font-size: 1rem; font-weight: 600; color: #e6edf3; }

    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      font-size: 0.82rem;
      color: #8b949e;
    }
    .meta-row span { white-space: nowrap; }
    .meta-row strong { color: #c9d1d9; }

    /* ì›¹ì†Œì¼“ ìƒíƒœ ë„íŠ¸ */
    #ws-dot {
      display: inline-block;
      width: 9px; height: 9px;
      border-radius: 50%;
      background: #6e7681;
      margin-right: 4px;
      vertical-align: middle;
      transition: background 0.3s;
    }
    #ws-dot.connected    { background: #3fb950; box-shadow: 0 0 6px #3fb95088; }
    #ws-dot.connecting   { background: #d29922; }
    #ws-dot.disconnected { background: #f85149; }

    /* â”€â”€ ë²„íŠ¼ ê·¸ë£¹ â”€â”€ */
    .btn-group { display: flex; gap: 8px; align-items: center; }
    button {
      padding: 7px 14px;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      font-family: inherit;
      transition: opacity 0.15s;
    }
    button:hover { opacity: 0.85; }
    #btn-snapshot { background: #2962ff; color: #fff; }
    #btn-reset    { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; }

    /* ë·° í† ê¸€ */
    .view-toggle {
      display: flex;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #30363d;
    }
    .view-toggle button {
      background: #21262d;
      color: #6e7681;
      border: none;
      border-radius: 0;
      padding: 6px 14px;
      font-size: 0.78rem;
      letter-spacing: 0.02em;
    }
    .view-toggle button:hover { background: #2d333b; color: #c9d1d9; opacity: 1; }
    .view-toggle button.active { background: #1f6feb; color: #fff; }

    /* â”€â”€ ì°¨íŠ¸ ì˜ì—­ â”€â”€ */
    #chart-wrapper {
      position: relative;
      background: #131722;
      border: 1px solid #30363d;
      border-radius: 8px;
      overflow: hidden;
      flex: 1;
      min-height: 460px;
    }
    #chart-container { width: 100%; height: 100%; min-height: 460px; }

    /* ì°¨íŠ¸ ìœ„ ì˜¤ë²„ë ˆì´ ë©”ì‹œì§€ (ì´ˆê¸° ì—°ê²° ëŒ€ê¸° ë“±) */
    #chart-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(19,23,34,0.7);
      font-size: 1rem;
      color: #8b949e;
      pointer-events: none;
      transition: opacity 0.4s;
    }
    #chart-overlay.hidden { opacity: 0; }

    /* â”€â”€ í†µê³„ ë°” â”€â”€ */
    #stats-bar {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 10px 18px;
      font-size: 0.82rem;
    }
    .stat-item { display: flex; flex-direction: column; gap: 2px; }
    .stat-label { color: #8b949e; font-size: 0.73rem; text-transform: uppercase; letter-spacing: 0.04em; }
    .stat-value { color: #e6edf3; font-size: 0.95rem; font-weight: 600; font-variant-numeric: tabular-nums; }
    .stat-value.up   { color: #3fb950; }
    .stat-value.down { color: #f85149; }

    /* â”€â”€ ìŠ¤ëƒ…ìƒ· ê°¤ëŸ¬ë¦¬ â”€â”€ */
    #gallery {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 18px;
    }
    #gallery h3 { font-size: 0.85rem; color: #8b949e; margin-bottom: 10px; }
    #snapshot-list {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .snap-thumb {
      position: relative;
      cursor: pointer;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
      transition: border-color 0.15s;
    }
    .snap-thumb:hover { border-color: #58a6ff; }
    .snap-thumb img  { display: block; width: 160px; height: 80px; object-fit: cover; }
    .snap-thumb span {
      display: block;
      text-align: center;
      font-size: 0.65rem;
      color: #8b949e;
      padding: 3px 4px;
      background: #0d1117;
    }

    /* â”€â”€ ì „ì²´í™”ë©´ ìŠ¤ëƒ…ìƒ· ë·°ì–´ â”€â”€ */
    #viewer-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    #viewer-overlay.visible { display: flex; }
    #viewer-overlay img {
      max-width: 95vw;
      max-height: 90vh;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    #viewer-close {
      position: absolute;
      top: 18px; right: 22px;
      color: #fff;
      font-size: 1.6rem;
      cursor: pointer;
      line-height: 1;
    }
  </style>
</head>
<body>

<!-- â‘  í—¤ë” íŒ¨ë„ -->
<div id="header">
  <div>
    <h1>ğŸ¯ BTC/USDT 1ë¶„ë´‰ &nbsp;ì ì¤‘ë¥  ê²€ì¦ ì°¨íŠ¸</h1>
    <div class="meta-row" style="margin-top:6px;">
      <span><strong id="lbl-period">ê³„ì‚° ì¤‘...</strong></span>
      <span>í˜„ì¬: <strong id="lbl-time">--:--</strong></span>
      <span><span id="ws-dot"></span><span id="lbl-ws">ì—°ê²° ì¤‘...</span></span>
    </div>
  </div>
  <div class="btn-group">
    <div class="view-toggle">
      <button id="btn-view-candle" class="active">ìº”ë“¤</button>
      <button id="btn-view-line">ë¼ì¸</button>
    </div>
    <button id="btn-snapshot">ğŸ“· ìˆ˜ë™ ìŠ¤ëƒ…ìƒ·</button>
    <button id="btn-reset">ğŸ”„ ì°¨íŠ¸ ì´ˆê¸°í™”</button>
  </div>
</div>

<!-- â‘¡ ì°¨íŠ¸ -->
<div id="chart-wrapper">
  <div id="chart-container"></div>
  <div id="chart-overlay">â³ Binance WebSocket ì—°ê²° ëŒ€ê¸° ì¤‘...</div>
</div>

<!-- â‘¢ í†µê³„ ë°” -->
<div id="stats-bar">
  <div class="stat-item">
    <span class="stat-label">í˜„ì¬ê°€</span>
    <span class="stat-value" id="stat-price">--</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ëˆ„ì  ìº”ë“¤</span>
    <span class="stat-value" id="stat-candles">0</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ì˜ˆì¸¡ ê¶¤ì </span>
    <span class="stat-value" id="stat-preds">0</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">êµ¬ê°„ ë³€í™”</span>
    <span class="stat-value" id="stat-change">--</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ë‹¤ìŒ ìŠ¤ëƒ…ìƒ·ê¹Œì§€</span>
    <span class="stat-value" id="stat-countdown">--</span>
  </div>
</div>

<!-- â‘£ ìŠ¤ëƒ…ìƒ· ê°¤ëŸ¬ë¦¬ -->
<div id="gallery">
  <h3>ğŸ“‚ ìŠ¤ëƒ…ìƒ· íˆìŠ¤í† ë¦¬</h3>
  <div id="snapshot-list"><span style="color:#6e7681;font-size:.8rem;">ì €ì¥ëœ ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.</span></div>
</div>

<!-- â‘¤ ìŠ¤ëƒ…ìƒ· ë·°ì–´ -->
<div id="viewer-overlay">
  <span id="viewer-close">âœ•</span>
  <img id="viewer-img" src="" alt="snapshot" />
</div>

<script>
// ============================================================
//  ìœ í‹¸ë¦¬í‹°
// ============================================================
const pad  = n => String(n).padStart(2, '0');
const fmt  = n => n.toLocaleString('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

/**
 * Lightweight ChartsëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ UTCë¡œ í•´ì„í•©ë‹ˆë‹¤.
 * ë¡œì»¬ ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•˜ë ¤ë©´ UTC íƒ€ì„ìŠ¤íƒ¬í”„ì— ë¡œì»¬ ì˜¤í”„ì…‹ì„ ë”í•©ë‹ˆë‹¤.
 * ì˜ˆ) KST(+9h): UTCì´ˆ + 32400 â†’ ì°¨íŠ¸ì— ë¡œì»¬ ì‹œê°ìœ¼ë¡œ í‘œì‹œ
 */
const TZ_OFFSET_S = new Date().getTimezoneOffset() * -60;
function toChartTime(ms) {
  return Math.floor(ms / 1000) + TZ_OFFSET_S;
}

// ============================================================
//  ì°¨íŠ¸ ìƒì„±
// ============================================================
const chartContainer = document.getElementById('chart-container');
const chart = LightweightCharts.createChart(chartContainer, {
  layout: {
    background: { type: 'solid', color: '#131722' },
    textColor: '#d1d4dc',
  },
  grid: {
    vertLines: { color: '#1e2130' },
    horzLines: { color: '#1e2130' },
  },
  timeScale: {
    timeVisible: true,
    secondsVisible: false,
    fixLeftEdge: true,
    fixRightEdge: true,
    borderColor: '#2b2b43',
  },
  rightPriceScale: {
    autoScale: true,
    borderColor: '#2b2b43',
  },
  crosshair: {
    mode: LightweightCharts.CrosshairMode.Normal,
  },
  handleScroll: { mouseWheel: false, pressedMouseMove: false, horzTouchDrag: false },
  handleScale:  { mouseWheel: false, pinch: false, axisPressedMouseMove: false },
});

// ì°½ í¬ê¸°ì— ë§ê²Œ ì°¨íŠ¸ ìë™ ì¡°ì ˆ
const resizeObserver = new ResizeObserver(() => {
  chart.applyOptions({
    width:  chartContainer.clientWidth,
    height: chartContainer.clientHeight,
  });
});
resizeObserver.observe(chartContainer);

// ìº”ë“¤ìŠ¤í‹± ì‹œë¦¬ì¦ˆ (ì‹¤ì œ 1ë¶„ë´‰)
const candleSeries = chart.addCandlestickSeries({
  upColor:       '#26a69a',
  downColor:     '#ef5350',
  borderVisible: false,
  wickUpColor:   '#26a69a',
  wickDownColor: '#ef5350',
});

// ë¼ì¸ ë·°ìš© ì—ë¦¬ì–´ ì‹œë¦¬ì¦ˆ (ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€)
const realAreaSeries = chart.addAreaSeries({
  topColor:              'rgba(88, 166, 255, 0.18)',
  bottomColor:           'rgba(88, 166, 255, 0.0)',
  lineColor:             '#58a6ff',
  lineWidth:             2,
  crosshairMarkerVisible: true,
  crosshairMarkerRadius:  4,
  lastValueVisible:      true,
  priceLineVisible:      true,
  priceLineColor:        'rgba(88,166,255,0.5)',
});

// â”€â”€ Anchor ì‹œë¦¬ì¦ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ì‹œê°„ ì°½(13:00~13:59) ì–‘ëì— íˆ¬ëª… í¬ì¸íŠ¸ë¥¼ ê³ ì •í•´ Xì¶• ë²”ìœ„ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
// autoscaleInfoProvider: () => null â†’ Yì¶• ìë™ ìŠ¤ì¼€ì¼ì—ì„œ ì™„ì „íˆ ì œì™¸ë©ë‹ˆë‹¤.
const anchorSeries = chart.addLineSeries({
  color:                 'rgba(0,0,0,0)',
  lineWidth:             0,
  crosshairMarkerVisible: false,
  lastValueVisible:      false,
  priceLineVisible:      false,
  autoscaleInfoProvider: () => null,
});

// ============================================================
//  1ì‹œê°„ ê³ ì • íƒ€ì„ë¼ì¸ (ì˜ˆ: 13:00 ~ 13:59)
// ============================================================
let periodStart  = null;   // Date
let periodEnd    = null;   // Date
let _rangeFixed  = false;  // setVisibleRangeê°€ ì‹¤ì œë¡œ ì ìš©ëëŠ”ì§€ ì—¬ë¶€

function calcPeriod(now) {
  const s = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0);
  const e = new Date(s.getTime() + 3600 * 1000);  // +1ì‹œê°„
  return { start: s, end: e };
}

/**
 * ì‹œê°„ì¶•ì„ 13:00~14:00ê¹Œì§€ ë¯¸ë¦¬ 61ê°œ í‹±ìœ¼ë¡œ ê³ ì •.
 * ì¶•ì€ ì²˜ìŒë¶€í„° ë§Œë“¤ê³ , ì‹¤ì œ ë°ì´í„°ë§Œ í•´ë‹¹ ìŠ¬ë¡¯ì— ì±„ì›Œì§.
 */
function applyTimeAxisRange() {
  if (!periodStart || !periodEnd) return;
  const fromTs = toChartTime(periodStart.getTime());
  const toTs   = toChartTime(periodEnd.getTime());
  const anchorVal = lastClose && lastClose > 0 ? lastClose : 50000;
  // 61ê°œ í¬ì¸íŠ¸ (13:00, 13:01, ... 13:59, 14:00) â†’ ì‹œê°„ì¶• í‹± ë¯¸ë¦¬ ìƒì„±
  const anchorData = [];
  for (let t = fromTs; t <= toTs; t += 60) {
    anchorData.push({ time: t, value: anchorVal });
  }
  anchorSeries.setData(anchorData);
  try {
    chart.timeScale().setVisibleRange({ from: fromTs, to: toTs });
    _rangeFixed = true;
  } catch (_) {}
}

function applyFixedTimeline(start, end) {
  const startStr = `${pad(start.getHours())}:${pad(start.getMinutes())}`;
  const endStr   = `${pad(end.getHours())}:${pad(end.getMinutes())}`;
  document.getElementById('lbl-period').textContent =
    `í˜„ì¬ êµ¬ê°„: ${startStr} ~ ${endStr}`;
  applyTimeAxisRange();
}

// ============================================================
//  ì°¨íŠ¸ ìƒíƒœ
// ============================================================
let predictionSeriesList = [];   // ëˆ„ì  ì˜ˆì¸¡ LineSeries ëª©ë¡
let candleCount   = 0;
let lastCandleTs  = 0;           // ë§ˆì§€ë§‰ìœ¼ë¡œ ì¹´ìš´íŠ¸í•œ ìº”ë“¤ì˜ timestamp (ì¤‘ë³µ ë°©ì§€)
let periodOpen    = null;        // êµ¬ê°„ ì²« ë²ˆì§¸ ìº”ë“¤ ì‹œê°€ (ë³€í™”ìœ¨ ê³„ì‚°ìš©)
let lastClose     = null;

// ë·° ëª¨ë“œ & ë°ì´í„° ë²„í¼ (ëª¨ë“œ ì „í™˜ ì‹œ ì¬í™œìš©)
let viewMode   = 'candle';  // 'candle' | 'line'
let candleData = [];        // { time, open, high, low, close }[]
let lineData   = [];        // { time, value }[]

function switchView(mode) {
  if (mode === viewMode) return;
  viewMode = mode;

  document.getElementById('btn-view-candle').classList.toggle('active', mode === 'candle');
  document.getElementById('btn-view-line').classList.toggle('active', mode === 'line');

  if (mode === 'line') {
    candleSeries.setData([]);
    realAreaSeries.setData(lineData);
  } else {
    realAreaSeries.setData([]);
    candleSeries.setData(candleData);
  }
  applyTimeAxisRange();
}

function resetChart() {
  // ëª¨ë“  ì˜ˆì¸¡ ì‹œë¦¬ì¦ˆ ì œê±°
  predictionSeriesList.forEach(s => {
    try { chart.removeSeries(s); } catch (_) {}
  });
  predictionSeriesList = [];

  // ìº”ë“¤ & ë¼ì¸ & anchor ì´ˆê¸°í™”
  candleData = [];
  lineData   = [];
  candleSeries.setData([]);
  realAreaSeries.setData([]);
  anchorSeries.setData([]);
  candleCount  = 0;
  lastCandleTs = 0;
  periodOpen   = null;
  _rangeFixed  = false;   // ìƒˆ êµ¬ê°„ì´ë¯€ë¡œ range ì¬í™•ì • í•„ìš”
  document.getElementById('stat-candles').textContent = '0';
  document.getElementById('stat-preds').textContent   = '0';
  document.getElementById('stat-change').textContent  = '--';
  document.getElementById('stat-change').className    = 'stat-value';

  // ìƒˆ êµ¬ê°„ íƒ€ì„ë¼ì¸ ì„¤ì •
  const { start, end } = calcPeriod(new Date());
  periodStart = start;
  periodEnd   = end;
  applyFixedTimeline(start, end);
}

// ì´ˆê¸°í™”
resetChart();

// ============================================================
//  ìŠ¤ëƒ…ìƒ·
// ============================================================
function makePeriodFilename(start, end) {
  const dateStr  = `${start.getFullYear()}-${pad(start.getMonth()+1)}-${pad(start.getDate())}`;
  const startStr = `${pad(start.getHours())}${pad(start.getMinutes())}`;
  const endStr   = `${pad(end.getHours())}${pad(end.getMinutes())}`;
  return `${dateStr}_${startStr}_${endStr}.png`;
}

async function captureAndSend(filename) {
  let dataURL = null;
  try {
    const canvas = chart.takeScreenshot();
    if (canvas && typeof canvas.toDataURL === 'function') {
      dataURL = canvas.toDataURL('image/png');
    }
  } catch (_) {}

  if (!dataURL) {
    // fallback: DOMì—ì„œ ìº”ë²„ìŠ¤ ì§ì ‘ íƒìƒ‰
    const canvas = chartContainer.querySelector('canvas');
    if (canvas) dataURL = canvas.toDataURL('image/png');
  }
  if (!dataURL) { console.warn('ìŠ¤ëƒ…ìƒ· ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }

  try {
    const res = await fetch('/save_snapshot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: dataURL, filename }),
    });
    const json = await res.json();
    console.log('ğŸ“¸ ìŠ¤ëƒ…ìƒ· ì €ì¥:', json.filename, `(${(json.size/1024).toFixed(1)} KB)`);
    loadSnapshotGallery();
  } catch (e) {
    console.error('ìŠ¤ëƒ…ìƒ· ì „ì†¡ ì‹¤íŒ¨:', e);
  }
}

async function takeSnapshotAndReset() {
  const filename = makePeriodFilename(periodStart, periodEnd);
  await captureAndSend(filename);
  resetChart();
}

document.getElementById('btn-snapshot').addEventListener('click', takeSnapshotAndReset);
document.getElementById('btn-reset').addEventListener('click', resetChart);
document.getElementById('btn-view-candle').addEventListener('click', () => switchView('candle'));
document.getElementById('btn-view-line').addEventListener('click', () => switchView('line'));

// ============================================================
//  ê°¤ëŸ¬ë¦¬
// ============================================================
async function loadSnapshotGallery() {
  try {
    const res  = await fetch('/snapshots');
    const data = await res.json();
    const list = document.getElementById('snapshot-list');
    if (!data.snapshots || data.snapshots.length === 0) {
      list.innerHTML = '<span style="color:#6e7681;font-size:.8rem;">ì €ì¥ëœ ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.</span>';
      return;
    }
    list.innerHTML = '';
    data.snapshots.forEach(name => {
      const thumb = document.createElement('div');
      thumb.className = 'snap-thumb';
      thumb.title = name;
      thumb.innerHTML = `<img src="/snapshots/${name}" alt="${name}" loading="lazy"><span>${name.replace('.png','')}</span>`;
      thumb.addEventListener('click', () => openViewer(`/snapshots/${name}`));
      list.appendChild(thumb);
    });
  } catch (_) {}
}

function openViewer(src) {
  const ov = document.getElementById('viewer-overlay');
  document.getElementById('viewer-img').src = src;
  ov.classList.add('visible');
}
document.getElementById('viewer-close').addEventListener('click', () => {
  document.getElementById('viewer-overlay').classList.remove('visible');
});
document.getElementById('viewer-overlay').addEventListener('click', e => {
  if (e.target === e.currentTarget) e.currentTarget.classList.remove('visible');
});

loadSnapshotGallery();

// ============================================================
//  UI íƒ€ì´ë¨¸ (1ì´ˆë§ˆë‹¤ ì‹œê° + ì¹´ìš´íŠ¸ë‹¤ìš´ ê°±ì‹ )
// ============================================================
function updateUI() {
  const now = new Date();
  document.getElementById('lbl-time').textContent =
    `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;

  if (periodEnd) {
    const remainMs = periodEnd.getTime() - now.getTime();
    if (remainMs > 0) {
      const mm = Math.floor(remainMs / 60000);
      const ss = Math.floor((remainMs % 60000) / 1000);
      document.getElementById('stat-countdown').textContent = `${pad(mm)}:${pad(ss)}`;
    } else {
      document.getElementById('stat-countdown').textContent = '00:00';
    }
  }
}
setInterval(updateUI, 1000);
updateUI();

// ============================================================
//  WebSocket ì—°ê²° (ìë™ ì¬ì—°ê²° í¬í•¨)
// ============================================================
let ws = null;
let wsRetryDelay = 2000;
let firstCandleReceived = false;

function setWsStatus(status, text) {
  const dot = document.getElementById('ws-dot');
  const lbl = document.getElementById('lbl-ws');
  dot.className = status;
  lbl.textContent = text;
}

function connectWS() {
  setWsStatus('connecting', 'ì—°ê²° ì¤‘...');
  ws = new WebSocket(`ws://${location.host}/ws`);

  ws.onopen = () => {
    setWsStatus('connected', 'ì—°ê²°ë¨ ğŸŸ¢');
    wsRetryDelay = 2000;
    console.log('âœ… WebSocket ì—°ê²°');
  };

  ws.onclose = () => {
    setWsStatus('disconnected', `ì¬ì—°ê²° ì¤‘... (${wsRetryDelay/1000}s)`);
    console.warn(`WebSocket ë‹«í˜, ${wsRetryDelay}ms í›„ ì¬ì—°ê²°`);
    setTimeout(connectWS, wsRetryDelay);
    wsRetryDelay = Math.min(wsRetryDelay * 2, 30000);
  };

  ws.onerror = err => {
    console.error('WebSocket ì˜¤ë¥˜:', err);
  };

  ws.onmessage = (event) => {
    let data;
    try { data = JSON.parse(event.data); }
    catch (_) { return; }

    const now = new Date();

    // ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
    if (!firstCandleReceived) {
      firstCandleReceived = true;
      const ov = document.getElementById('chart-overlay');
      ov.classList.add('hidden');
    }

    // â”€â”€ hour_history: ì ‘ì† ì‹œ í•´ë‹¹ 1ì‹œê°„ êµ¬ê°„ ê³¼ê±° ë¶„ë´‰ ë¡œë“œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'hour_history' && Array.isArray(data.candles)) {
      const candles = data.candles;
      const ps = data.period_start ? data.period_start * 1000 : null;
      const pe = data.period_end ? data.period_end * 1000 : null;
      if (ps && pe) {
        periodStart = new Date(ps);
        periodEnd   = new Date(pe);
        applyFixedTimeline(periodStart, periodEnd);
      }
      _rangeFixed = false;
      candleData = [];
      lineData   = [];
      candleCount = 0;
      periodOpen = candles.length ? candles[0].open : null;
      lastClose  = candles.length ? candles[candles.length - 1].close : null;

      candles.forEach((c) => {
        const ts = toChartTime((c.time || 0) * 1000);
        candleData.push({ time: ts, open: c.open, high: c.high, low: c.low, close: c.close });
        lineData.push({ time: ts, value: c.close });
      });
      candleCount = candleData.length;
      lastCandleTs = candleData.length ? candleData[candleData.length - 1].time : 0;

      if (viewMode === 'candle') {
        candleSeries.setData(candleData);
        realAreaSeries.setData([]);
      } else {
        realAreaSeries.setData(lineData);
        candleSeries.setData([]);
      }
      anchorSeries.setData([]);
      applyTimeAxisRange();
      document.getElementById('stat-candles').textContent = candleCount;
      document.getElementById('stat-price').textContent = lastClose ? fmt(lastClose) : '--';
      const change = periodOpen ? ((lastClose - periodOpen) / periodOpen * 100) : 0;
      const el = document.getElementById('stat-change');
      el.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(3)}%`;
      el.className = `stat-value ${change >= 0 ? 'up' : 'down'}`;
      return;
    }

    // â”€â”€ 1ì‹œê°„ êµ¬ê°„ ê²½ê³„ ì²´í¬ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (periodEnd && now >= periodEnd) {
      console.log('â° 1ì‹œê°„ êµ¬ê°„ ì¢…ë£Œ â†’ ìŠ¤ëƒ…ìƒ· + ì´ˆê¸°í™”');
      takeSnapshotAndReset();
      return;
    }

    // â”€â”€ ì‹¤ì‹œê°„ ë¶„ë´‰ ì—…ë°ì´íŠ¸ (ë¶„ë‹¨ìœ„, ë™ì¼ ë¶„ì€ upsert) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'real_time_candle') {
      const c = data.candle;
      const ts = toChartTime((c.time || 0) * 1000);
      const chartCandle = { time: ts, open: c.open, high: c.high, low: c.low, close: c.close };
      const chartLine   = { time: ts, value: c.close };

      // time ê¸°ì¤€ upsert (ë¶„ë‹¨ìœ„ - ë™ì¼ ë¶„ì´ë©´ ë®ì–´ì“°ê¸°)
      let found = false;
      for (let i = 0; i < candleData.length; i++) {
        if (candleData[i].time === ts) {
          candleData[i] = chartCandle;
          lineData[i]   = chartLine;
          found = true;
          break;
        }
      }
      if (!found) {
        candleData.push(chartCandle);
        lineData.push(chartLine);
      }

      if (viewMode === 'candle') {
        candleSeries.update(chartCandle);
      } else {
        realAreaSeries.update(chartLine);
      }

      lastClose = c.close;
      if (periodOpen === null) periodOpen = c.open;

      if (ts !== lastCandleTs) {
        lastCandleTs = ts;
        candleCount = candleData.length;
        document.getElementById('stat-candles').textContent = candleCount;
      }

      // í˜„ì¬ê°€ & êµ¬ê°„ ë³€í™”ìœ¨
      document.getElementById('stat-price').textContent = fmt(c.close);
      const change = periodOpen ? ((c.close - periodOpen) / periodOpen * 100) : 0;
      const el = document.getElementById('stat-change');
      el.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(3)}%`;
      el.className   = `stat-value ${change >= 0 ? 'up' : 'down'}`;

      applyTimeAxisRange();
    }

    // â”€â”€ ì˜ˆì¸¡ ê¶¤ì  ì˜¤ë²„ë ˆì´ (ë¼ì¸ë·°ì—ì„œë„ ë³´ì´ë„ë¡ ì „ë©´ì— í‘œì‹œ) â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'prediction' && Array.isArray(data.predictions)) {

      const colors = ['#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
      const color = colors[predictionSeriesList.length % colors.length];

      const predSeries = chart.addLineSeries({
        color:                  color,
        lineWidth:              2.5,
        lineStyle:              LightweightCharts.LineStyle.Dashed,
        crosshairMarkerVisible: true,
        lastValueVisible:       true,
        priceLineVisible:       false,
      });

      const points = data.predictions.map(p => ({
        time:  toChartTime(p.time * 1000),
        value: p.value,
      }));

      // ì˜ˆì¸¡ ê¶¤ì ì˜ ì‹œì‘ì ì„ í˜„ì¬ ìº”ë“¤ ì¢…ê°€ì— ì—°ê²°
      if (lastClose !== null && points.length > 0) {
        const originTime = data.origin_time
          ? toChartTime(data.origin_time * 1000)
          : points[0].time - 60;
        predSeries.setData([{ time: originTime, value: lastClose }, ...points]);
      } else {
        predSeries.setData(points);
      }

      predictionSeriesList.push(predSeries);
      document.getElementById('stat-preds').textContent = predictionSeriesList.length;

      applyTimeAxisRange();
    }
  };
}

connectWS();
</script>
</body>
</html>
