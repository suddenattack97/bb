<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ê²€ì¦</title>

  <!-- Lightweight Charts v4 (standalone) -->
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Malgun Gothic', 'Segoe UI', sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 14px 18px;
    }

    /* â”€â”€ í—¤ë” íŒ¨ë„ â”€â”€ */
    #header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 18px;
    }
    #header h1 { font-size: 1rem; font-weight: 600; color: #e6edf3; }

    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      font-size: 0.82rem;
      color: #8b949e;
    }
    .meta-row span { white-space: nowrap; }
    .meta-row strong { color: #c9d1d9; }

    /* ì›¹ì†Œì¼“ ìƒíƒœ ë„íŠ¸ */
    #ws-dot {
      display: inline-block;
      width: 9px; height: 9px;
      border-radius: 50%;
      background: #6e7681;
      margin-right: 4px;
      vertical-align: middle;
      transition: background 0.3s;
    }
    #ws-dot.connected    { background: #3fb950; box-shadow: 0 0 6px #3fb95088; }
    #ws-dot.connecting   { background: #d29922; }
    #ws-dot.disconnected { background: #f85149; }

    /* â”€â”€ ë²„íŠ¼ ê·¸ë£¹ â”€â”€ */
    .btn-group { display: flex; gap: 8px; align-items: center; }
    button {
      padding: 7px 14px;
      border: none;
      border-radius: 6px;
      font-size: 0.8rem;
      cursor: pointer;
      font-family: inherit;
      transition: opacity 0.15s;
    }
    button:hover { opacity: 0.85; }
    #btn-snapshot { background: #2962ff; color: #fff; }
    #btn-reset    { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; }

    /* ë·° í† ê¸€ */
    .view-toggle {
      display: flex;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #30363d;
    }
    .view-toggle button {
      background: #21262d;
      color: #6e7681;
      border: none;
      border-radius: 0;
      padding: 6px 14px;
      font-size: 0.78rem;
      letter-spacing: 0.02em;
    }
    .view-toggle button:hover { background: #2d333b; color: #c9d1d9; opacity: 1; }
    .view-toggle button.active { background: #1f6feb; color: #fff; }

    /* â”€â”€ ì°¨íŠ¸ ì˜ì—­ â”€â”€ */
    #chart-wrapper {
      position: relative;
      background: #131722;
      border: 1px solid #30363d;
      border-radius: 8px;
      overflow: hidden;
      flex: 1;
      min-height: 460px;
    }
    #chart-container { width: 100%; height: 100%; min-height: 460px; }

    /* ì°¨íŠ¸ ìœ„ ì˜¤ë²„ë ˆì´ ë©”ì‹œì§€ (ì´ˆê¸° ì—°ê²° ëŒ€ê¸° ë“±) */
    #chart-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(19,23,34,0.7);
      font-size: 1rem;
      color: #8b949e;
      pointer-events: none;
      transition: opacity 0.4s;
    }
    #chart-overlay.hidden { opacity: 0; }

    /* â”€â”€ í†µê³„ ë°” â”€â”€ */
    #stats-bar {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 10px 18px;
      font-size: 0.82rem;
    }
    .stat-item { display: flex; flex-direction: column; gap: 2px; }
    .stat-label { color: #8b949e; font-size: 0.73rem; text-transform: uppercase; letter-spacing: 0.04em; }
    .stat-value { color: #e6edf3; font-size: 0.95rem; font-weight: 600; font-variant-numeric: tabular-nums; }
    .stat-value.up   { color: #3fb950; }
    .stat-value.down { color: #f85149; }
    #stats-bar .btn-debug { margin-left: auto; font-size: 0.75rem; padding: 5px 10px; background: #21262d; color: #8b949e; border: 1px solid #30363d; border-radius: 6px; cursor: pointer; }
    #stats-bar .btn-debug:hover { background: #2d333b; color: #c9d1d9; }

    /* â”€â”€ ìŠ¤ëƒ…ìƒ· ê°¤ëŸ¬ë¦¬ â”€â”€ */
    #gallery {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 12px 18px;
    }
    #gallery h3 { font-size: 0.85rem; color: #8b949e; margin-bottom: 10px; }
    #snapshot-list {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .snap-thumb {
      position: relative;
      cursor: pointer;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
      transition: border-color 0.15s;
    }
    .snap-thumb:hover { border-color: #58a6ff; }
    .snap-thumb img  { display: block; width: 160px; height: 80px; object-fit: cover; }
    .snap-thumb span {
      display: block;
      text-align: center;
      font-size: 0.65rem;
      color: #8b949e;
      padding: 3px 4px;
      background: #0d1117;
    }

    /* â”€â”€ ì „ì²´í™”ë©´ ìŠ¤ëƒ…ìƒ· ë·°ì–´ â”€â”€ */
    #viewer-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    #viewer-overlay.visible { display: flex; }
    #viewer-overlay img {
      max-width: 95vw;
      max-height: 90vh;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }
    #viewer-close {
      position: absolute;
      top: 18px; right: 22px;
      color: #fff;
      font-size: 1.6rem;
      cursor: pointer;
      line-height: 1;
    }

    /* â”€â”€ ì„œë²„ ë¡œê·¸ ì¸ë””ì¼€ì´í„° â”€â”€ */
    #log-indicator {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      overflow: hidden;
    }
    #log-indicator .log-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 14px;
      background: #0d1117;
      cursor: pointer;
      font-size: 0.8rem;
      color: #8b949e;
      user-select: none;
    }
    #log-indicator .log-header:hover { background: #161b22; color: #c9d1d9; }
    #log-indicator .log-header .log-badge {
      background: #238636;
      color: #fff;
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 4px;
    }
    #log-indicator .log-body {
      display: none;
      max-height: 280px;
      overflow: auto;
    }
    #log-indicator.expanded .log-body { display: block; }
    #log-indicator .log-content {
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.7rem;
      line-height: 1.4;
      padding: 10px 14px;
      color: #c9d1d9;
      white-space: pre-wrap;
      word-break: break-all;
    }
    #log-indicator .log-actions { padding: 6px 14px; display: flex; gap: 8px; border-top: 1px solid #21262d; }
    #log-indicator .log-actions button { font-size: 0.7rem; padding: 4px 10px; }
  </style>
</head>
<body>

<!-- â‘  í—¤ë” íŒ¨ë„ -->
<div id="header">
  <div>
    <h1>ğŸ¯ BTC/USDT 1ë¶„ë´‰ &nbsp;ì ì¤‘ë¥  ê²€ì¦ ì°¨íŠ¸</h1>
    <div class="meta-row" style="margin-top:6px;">
      <span><strong id="lbl-period">ê³„ì‚° ì¤‘...</strong></span>
      <span>í˜„ì¬: <strong id="lbl-time">--:--</strong></span>
      <span><span id="ws-dot"></span><span id="lbl-ws">ì—°ê²° ì¤‘...</span></span>
    </div>
  </div>
  <div class="btn-group">
    <div class="view-toggle">
      <button id="btn-view-candle" class="active">ìº”ë“¤</button>
      <button id="btn-view-line">ë¼ì¸</button>
    </div>
    <button id="btn-snapshot">ğŸ“· ìˆ˜ë™ ìŠ¤ëƒ…ìƒ·</button>
    <button id="btn-reset">ğŸ”„ ì°¨íŠ¸ ì´ˆê¸°í™”</button>
  </div>
</div>

<!-- â‘¡ ì°¨íŠ¸ -->
<div id="chart-wrapper">
  <div id="chart-container"></div>
  <div id="chart-overlay">â³ Binance WebSocket ì—°ê²° ëŒ€ê¸° ì¤‘...</div>
</div>

<!-- â‘¢ í†µê³„ ë°” -->
<div id="stats-bar">
  <div class="stat-item">
    <span class="stat-label">í˜„ì¬ê°€</span>
    <span class="stat-value" id="stat-price">--</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ëˆ„ì  ìº”ë“¤</span>
    <span class="stat-value" id="stat-candles">0</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ì˜ˆì¸¡ ê¶¤ì </span>
    <span class="stat-value" id="stat-preds">0</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">êµ¬ê°„ ë³€í™”</span>
    <span class="stat-value" id="stat-change">--</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ë‹¤ìŒ ìŠ¤ëƒ…ìƒ·ê¹Œì§€</span>
    <span class="stat-value" id="stat-countdown">--</span>
  </div>
  <div class="stat-item">
    <span class="stat-label">ëª¨ë¸</span>
    <span class="stat-value" id="stat-model">--</span>
  </div>
  <button id="btn-model-debug" class="btn-debug">ğŸ” ì˜ˆì¸¡ ê²€ì¦</button>
</div>

<!-- â‘£ ì„œë²„ ë¡œê·¸ ì¸ë””ì¼€ì´í„° -->
<div id="log-indicator">
  <div class="log-header">
    <span>ğŸ“‹ ì„œë²„ ë¡œê·¸ (data/logs/server.txt)</span>
    <span class="log-badge" id="log-badge">0 lines</span>
  </div>
  <div class="log-body">
    <pre class="log-content" id="log-content">ë¡œë”© ì¤‘...</pre>
    <div class="log-actions">
      <button id="btn-log-refresh" style="background:#238636;color:#fff;">ìƒˆë¡œê³ ì¹¨</button>
      <a id="btn-log-download" href="/api/logs/download" target="_blank" download="server.txt" style="background:#21262d;color:#c9d1d9;border:1px solid #30363d;border-radius:6px;padding:4px 10px;font-size:0.7rem;text-decoration:none;cursor:pointer;">ë‹¤ìš´ë¡œë“œ (.txt)</a>
    </div>
  </div>
</div>

<!-- â‘¤ ìŠ¤ëƒ…ìƒ· ê°¤ëŸ¬ë¦¬ -->
<div id="gallery">
  <h3>ğŸ“‚ ìŠ¤ëƒ…ìƒ· íˆìŠ¤í† ë¦¬</h3>
  <div id="snapshot-list"><span style="color:#6e7681;font-size:.8rem;">ì €ì¥ëœ ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.</span></div>
</div>

<!-- â‘¥ ìŠ¤ëƒ…ìƒ· ë·°ì–´ -->
<div id="viewer-overlay">
  <span id="viewer-close">âœ•</span>
  <img id="viewer-img" src="" alt="snapshot" />
</div>

<script>
// ============================================================
//  ìœ í‹¸ë¦¬í‹°
// ============================================================
const pad  = n => String(n).padStart(2, '0');
const fmt  = n => n.toLocaleString('ko-KR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

/**
 * Lightweight ChartsëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ UTCë¡œ í•´ì„í•©ë‹ˆë‹¤.
 * ë¡œì»¬ ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•˜ë ¤ë©´ UTC íƒ€ì„ìŠ¤íƒ¬í”„ì— ë¡œì»¬ ì˜¤í”„ì…‹ì„ ë”í•©ë‹ˆë‹¤.
 * ì˜ˆ) KST(+9h): UTCì´ˆ + 32400 â†’ ì°¨íŠ¸ì— ë¡œì»¬ ì‹œê°ìœ¼ë¡œ í‘œì‹œ
 */
const TZ_OFFSET_S = new Date().getTimezoneOffset() * -60;
function toChartTime(ms) {
  return Math.floor(ms / 1000) + TZ_OFFSET_S;
}

// ============================================================
//  ì°¨íŠ¸ ìƒì„±
// ============================================================
const chartContainer = document.getElementById('chart-container');
const chart = LightweightCharts.createChart(chartContainer, {
  layout: {
    background: { type: 'solid', color: '#131722' },
    textColor: '#d1d4dc',
  },
  grid: {
    vertLines: { color: '#1e2130' },
    horzLines: { color: '#1e2130' },
  },
  timeScale: {
    timeVisible: true,
    secondsVisible: false,
    fixLeftEdge: true,
    fixRightEdge: true,
    borderColor: '#2b2b43',
  },
  rightPriceScale: {
    autoScale: true,
    borderColor: '#2b2b43',
  },
  crosshair: {
    mode: LightweightCharts.CrosshairMode.Normal,
  },
  handleScroll: { mouseWheel: false, pressedMouseMove: false, horzTouchDrag: false },
  handleScale:  { mouseWheel: false, pinch: false, axisPressedMouseMove: false },
});

// ì°½ í¬ê¸°ì— ë§ê²Œ ì°¨íŠ¸ ìë™ ì¡°ì ˆ
const resizeObserver = new ResizeObserver(() => {
  chart.applyOptions({
    width:  chartContainer.clientWidth,
    height: chartContainer.clientHeight,
  });
});
resizeObserver.observe(chartContainer);

// ìº”ë“¤ìŠ¤í‹± ì‹œë¦¬ì¦ˆ (ì‹¤ì œ 1ë¶„ë´‰)
const candleSeries = chart.addCandlestickSeries({
  upColor:       '#26a69a',
  downColor:     '#ef5350',
  borderVisible: false,
  wickUpColor:   '#26a69a',
  wickDownColor: '#ef5350',
});

// ë¼ì¸ ë·°ìš© ì—ë¦¬ì–´ ì‹œë¦¬ì¦ˆ (ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€)
const realAreaSeries = chart.addAreaSeries({
  topColor:              'rgba(88, 166, 255, 0.18)',
  bottomColor:           'rgba(88, 166, 255, 0.0)',
  lineColor:             '#58a6ff',
  lineWidth:             2,
  crosshairMarkerVisible: true,
  crosshairMarkerRadius:  4,
  lastValueVisible:      true,
  priceLineVisible:      true,
  priceLineColor:        'rgba(88,166,255,0.5)',
});

// â”€â”€ Anchor ì‹œë¦¬ì¦ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1ì‹œê°„ ì°½(13:00~13:59) ì–‘ëì— íˆ¬ëª… í¬ì¸íŠ¸ë¥¼ ê³ ì •í•´ Xì¶• ë²”ìœ„ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
// autoscaleInfoProvider: () => null â†’ Yì¶• ìë™ ìŠ¤ì¼€ì¼ì—ì„œ ì™„ì „íˆ ì œì™¸ë©ë‹ˆë‹¤.
const anchorSeries = chart.addLineSeries({
  color:                 'rgba(0,0,0,0)',
  lineWidth:             0,
  crosshairMarkerVisible: false,
  lastValueVisible:      false,
  priceLineVisible:      false,
  autoscaleInfoProvider: () => null,
});

// ============================================================
//  1ì‹œê°„ ê³ ì • íƒ€ì„ë¼ì¸ (ì˜ˆ: 13:00 ~ 13:59)
// ============================================================
let periodStart  = null;   // Date
let periodEnd    = null;   // Date
let periodIsPast = false;  // ì´ë¯¸ ì§€ë‚œ êµ¬ê°„(ì¬ì‹œì‘ í›„ ë¡œë“œ)ì´ë©´ ìë™ ìŠ¤ëƒ…ìƒ· ì•ˆ í•¨
let _rangeFixed  = false;  // setVisibleRangeê°€ ì‹¤ì œë¡œ ì ìš©ëëŠ”ì§€ ì—¬ë¶€

function calcPeriod(now) {
  const s = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0);
  const e = new Date(s.getTime() + 3600 * 1000);  // +1ì‹œê°„
  return { start: s, end: e };
}

/**
 * ì‹œê°„ì¶•ì„ 13:00~14:00ê¹Œì§€ ë¯¸ë¦¬ 61ê°œ í‹±ìœ¼ë¡œ ê³ ì •.
 * ì¶•ì€ ì²˜ìŒë¶€í„° ë§Œë“¤ê³ , ì‹¤ì œ ë°ì´í„°ë§Œ í•´ë‹¹ ìŠ¬ë¡¯ì— ì±„ì›Œì§.
 */
function applyTimeAxisRange() {
  if (!periodStart || !periodEnd) return;
  const fromTs = toChartTime(periodStart.getTime());
  const toTs   = toChartTime(periodEnd.getTime());
  const anchorVal = lastClose && lastClose > 0 ? lastClose : 50000;
  // 61ê°œ í¬ì¸íŠ¸ (13:00, 13:01, ... 13:59, 14:00) â†’ ì‹œê°„ì¶• í‹± ë¯¸ë¦¬ ìƒì„±
  const anchorData = [];
  for (let t = fromTs; t <= toTs; t += 60) {
    anchorData.push({ time: t, value: anchorVal });
  }
  anchorSeries.setData(anchorData);
  try {
    chart.timeScale().setVisibleRange({ from: fromTs, to: toTs });
    _rangeFixed = true;
  } catch (_) {}
}

function applyFixedTimeline(start, end) {
  const startStr = `${pad(start.getHours())}:${pad(start.getMinutes())}`;
  const endStr   = `${pad(end.getHours())}:${pad(end.getMinutes())}`;
  document.getElementById('lbl-period').textContent =
    `í˜„ì¬ êµ¬ê°„: ${startStr} ~ ${endStr}`;
  applyTimeAxisRange();
}

// ============================================================
//  ì°¨íŠ¸ ìƒíƒœ
// ============================================================
let predictionSeriesList = [];   // ëˆ„ì  ì˜ˆì¸¡ LineSeries ëª©ë¡ (ì´ì „ ê²ƒì€ ì§€ìš°ì§€ ì•ŠìŒ)
let lastPredictionEndTs  = 0;    // ë§ˆì§€ë§‰ ì˜ˆì¸¡ì˜ ë ì‹œê° (chart time), ì´ ì‹œê° ë„ë‹¬ ì‹œì—ë§Œ ìƒˆ ì˜ˆì¸¡ ì¶”ê°€
let candleCount   = 0;
let lastCandleTs  = 0;           // ë§ˆì§€ë§‰ìœ¼ë¡œ ì¹´ìš´íŠ¸í•œ ìº”ë“¤ì˜ timestamp (ì¤‘ë³µ ë°©ì§€)
let periodOpen    = null;        // êµ¬ê°„ ì²« ë²ˆì§¸ ìº”ë“¤ ì‹œê°€ (ë³€í™”ìœ¨ ê³„ì‚°ìš©)
let lastClose     = null;

// ë·° ëª¨ë“œ & ë°ì´í„° ë²„í¼ (ëª¨ë“œ ì „í™˜ ì‹œ ì¬í™œìš©)
let viewMode   = 'candle';  // 'candle' | 'line'
let candleData = [];        // { time, open, high, low, close }[]
let lineData   = [];        // { time, value }[]

function switchView(mode) {
  if (mode === viewMode) return;
  viewMode = mode;

  document.getElementById('btn-view-candle').classList.toggle('active', mode === 'candle');
  document.getElementById('btn-view-line').classList.toggle('active', mode === 'line');

  if (mode === 'line') {
    candleSeries.setData([]);
    realAreaSeries.setData(lineData);
  } else {
    realAreaSeries.setData([]);
    candleSeries.setData(candleData);
  }
  applyTimeAxisRange();
}

function resetChart() {
  // ëª¨ë“  ì˜ˆì¸¡ ì‹œë¦¬ì¦ˆ ì œê±°
  predictionSeriesList.forEach(s => {
    try { chart.removeSeries(s); } catch (_) {}
  });
  predictionSeriesList = [];
  lastPredictionEndTs  = 0;

  // ìº”ë“¤ & ë¼ì¸ & anchor ì´ˆê¸°í™”
  candleData = [];
  lineData   = [];
  candleSeries.setData([]);
  realAreaSeries.setData([]);
  anchorSeries.setData([]);
  candleCount  = 0;
  lastCandleTs = 0;
  periodOpen   = null;
  _rangeFixed  = false;   // ìƒˆ êµ¬ê°„ì´ë¯€ë¡œ range ì¬í™•ì • í•„ìš”
  document.getElementById('stat-candles').textContent = '0';
  document.getElementById('stat-preds').textContent   = '0';
  document.getElementById('stat-change').textContent  = '--';
  document.getElementById('stat-change').className    = 'stat-value';

  // ìƒˆ êµ¬ê°„ íƒ€ì„ë¼ì¸ ì„¤ì • (ì‹¤ì‹œê°„ ëª¨ë“œ)
  periodIsPast = false;
  const { start, end } = calcPeriod(new Date());
  periodStart = start;
  periodEnd   = end;
  applyFixedTimeline(start, end);
}

// ì´ˆê¸°í™”
resetChart();

// ============================================================
//  ìŠ¤ëƒ…ìƒ·
// ============================================================
function makePeriodFilename(start, end) {
  const dateStr  = `${start.getFullYear()}-${pad(start.getMonth()+1)}-${pad(start.getDate())}`;
  const startStr = `${pad(start.getHours())}${pad(start.getMinutes())}`;
  const endStr   = `${pad(end.getHours())}${pad(end.getMinutes())}`;
  return `${dateStr}_${startStr}_${endStr}.png`;
}

async function captureAndSend(filename) {
  let dataURL = null;
  try {
    const canvas = chart.takeScreenshot();
    if (canvas && typeof canvas.toDataURL === 'function') {
      dataURL = canvas.toDataURL('image/png');
    }
  } catch (_) {}

  if (!dataURL) {
    // fallback: DOMì—ì„œ ìº”ë²„ìŠ¤ ì§ì ‘ íƒìƒ‰
    const canvas = chartContainer.querySelector('canvas');
    if (canvas) dataURL = canvas.toDataURL('image/png');
  }
  if (!dataURL) { console.warn('ìŠ¤ëƒ…ìƒ· ìº”ë²„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }

  try {
    const res = await fetch('/save_snapshot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ data: dataURL, filename }),
    });
    const json = await res.json();
    console.log('ğŸ“¸ ìŠ¤ëƒ…ìƒ· ì €ì¥:', json.filename, `(${(json.size/1024).toFixed(1)} KB)`);
    loadSnapshotGallery();
  } catch (e) {
    console.error('ìŠ¤ëƒ…ìƒ· ì „ì†¡ ì‹¤íŒ¨:', e);
  }
}

async function takeSnapshotAndReset() {
  const filename = makePeriodFilename(periodStart, periodEnd);
  await captureAndSend(filename);
  resetChart();
}

document.getElementById('btn-snapshot').addEventListener('click', takeSnapshotAndReset);
document.getElementById('btn-reset').addEventListener('click', resetChart);
document.getElementById('btn-view-candle').addEventListener('click', () => switchView('candle'));
document.getElementById('btn-view-line').addEventListener('click', () => switchView('line'));

// ëª¨ë¸ ìƒíƒœ ë¡œë“œ ë° ê²€ì¦ ë²„íŠ¼
async function refreshModelStatus() {
  try {
    const res = await fetch('/status');
    const d = await res.json();
    document.getElementById('stat-model').textContent = d.model || '--';
  } catch (_) {}
}
refreshModelStatus();
setInterval(refreshModelStatus, 10000);

document.getElementById('btn-model-debug').addEventListener('click', async () => {
  try {
    const res = await fetch('/api/model_debug');
    const d = await res.json();
    const msg = d.model === 'TCN'
      ? `ëª¨ë¸: TCN âœ…\nì…ë ¥ ì¢…ê°€: ${d.input_last_close}\nì˜ˆì¸¡ log_return(5ë¶„): [${(d.pred_log_returns||[]).map(x=>x.toFixed(6)).join(', ')}]\nì˜ˆì¸¡ ê°€ê²©: [${(d.pred_prices||[]).join(', ')}]`
      : `ëª¨ë¸: ${d.model || 'unknown'}\n${d.error || d.reason || ''}`;
    alert(msg);
    console.log('model_debug:', d);
  } catch (e) {
    alert('ê²€ì¦ API ì˜¤ë¥˜: ' + e.message);
  }
});

// ============================================================
//  ê°¤ëŸ¬ë¦¬
// ============================================================
async function loadSnapshotGallery() {
  try {
    const res  = await fetch('/snapshots');
    const data = await res.json();
    const list = document.getElementById('snapshot-list');
    if (!data.snapshots || data.snapshots.length === 0) {
      list.innerHTML = '<span style="color:#6e7681;font-size:.8rem;">ì €ì¥ëœ ìŠ¤ëƒ…ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.</span>';
      return;
    }
    list.innerHTML = '';
    data.snapshots.forEach(name => {
      const thumb = document.createElement('div');
      thumb.className = 'snap-thumb';
      thumb.title = name;
      thumb.innerHTML = `<img src="/snapshots/${name}" alt="${name}" loading="lazy"><span>${name.replace('.png','')}</span>`;
      thumb.addEventListener('click', () => openViewer(`/snapshots/${name}`));
      list.appendChild(thumb);
    });
  } catch (_) {}
}

function openViewer(src) {
  const ov = document.getElementById('viewer-overlay');
  document.getElementById('viewer-img').src = src;
  ov.classList.add('visible');
}
document.getElementById('viewer-close').addEventListener('click', () => {
  document.getElementById('viewer-overlay').classList.remove('visible');
});
document.getElementById('viewer-overlay').addEventListener('click', e => {
  if (e.target === e.currentTarget) e.currentTarget.classList.remove('visible');
});

loadSnapshotGallery();

// ============================================================
//  ì„œë²„ ë¡œê·¸ ì¸ë””ì¼€ì´í„°
// ============================================================
async function loadLogs() {
  try {
    const res = await fetch('/api/logs?tail=500');
    const d = await res.json();
    const pre = document.getElementById('log-content');
    const badge = document.getElementById('log-badge');
    pre.textContent = d.content || '(ë¹„ì–´ ìˆìŒ)';
    badge.textContent = `${d.lines ?? 0} lines`;
  } catch (e) {
    document.getElementById('log-content').textContent = `ë¡œë“œ ì‹¤íŒ¨: ${e.message}`;
  }
}

document.querySelector('#log-indicator .log-header').addEventListener('click', () => {
  document.getElementById('log-indicator').classList.toggle('expanded');
  if (document.getElementById('log-indicator').classList.contains('expanded')) {
    loadLogs();
  }
});

document.getElementById('btn-log-refresh').addEventListener('click', (e) => {
  e.preventDefault();
  loadLogs();
});

// í¼ì³ì§„ ìƒíƒœì—ì„œ 5ì´ˆë§ˆë‹¤ ìë™ ê°±ì‹ 
setInterval(() => {
  if (document.getElementById('log-indicator').classList.contains('expanded')) {
    loadLogs();
  }
}, 5000);

// ============================================================
//  UI íƒ€ì´ë¨¸ (1ì´ˆë§ˆë‹¤ ì‹œê° + ì¹´ìš´íŠ¸ë‹¤ìš´ ê°±ì‹ )
// ============================================================
function updateUI() {
  const now = new Date();
  document.getElementById('lbl-time').textContent =
    `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;

  if (periodEnd) {
    const remainMs = periodEnd.getTime() - now.getTime();
    if (remainMs > 0) {
      const mm = Math.floor(remainMs / 60000);
      const ss = Math.floor((remainMs % 60000) / 1000);
      document.getElementById('stat-countdown').textContent = `${pad(mm)}:${pad(ss)}`;
    } else {
      document.getElementById('stat-countdown').textContent = '00:00';
    }
  }
}
setInterval(updateUI, 1000);
updateUI();

// ============================================================
//  WebSocket ì—°ê²° (ìë™ ì¬ì—°ê²° í¬í•¨)
// ============================================================
let ws = null;
let wsRetryDelay = 2000;
let firstCandleReceived = false;

function setWsStatus(status, text) {
  const dot = document.getElementById('ws-dot');
  const lbl = document.getElementById('lbl-ws');
  dot.className = status;
  lbl.textContent = text;
}

function connectWS() {
  setWsStatus('connecting', 'ì—°ê²° ì¤‘...');
  ws = new WebSocket(`ws://${location.host}/ws`);

  ws.onopen = () => {
    setWsStatus('connected', 'ì—°ê²°ë¨ ğŸŸ¢');
    wsRetryDelay = 2000;
    console.log('âœ… WebSocket ì—°ê²°');
  };

  ws.onclose = () => {
    setWsStatus('disconnected', `ì¬ì—°ê²° ì¤‘... (${wsRetryDelay/1000}s)`);
    console.warn(`WebSocket ë‹«í˜, ${wsRetryDelay}ms í›„ ì¬ì—°ê²°`);
    setTimeout(connectWS, wsRetryDelay);
    wsRetryDelay = Math.min(wsRetryDelay * 2, 30000);
  };

  ws.onerror = err => {
    console.error('WebSocket ì˜¤ë¥˜:', err);
  };

  ws.onmessage = (event) => {
    let data;
    try { data = JSON.parse(event.data); }
    catch (_) { return; }

    const now = new Date();

    // ì˜¤ë²„ë ˆì´ ìˆ¨ê¹€
    if (!firstCandleReceived) {
      firstCandleReceived = true;
      const ov = document.getElementById('chart-overlay');
      ov.classList.add('hidden');
    }

    // â”€â”€ hour_history: ì ‘ì† ì‹œ í•´ë‹¹ 1ì‹œê°„ êµ¬ê°„ ê³¼ê±° ë¶„ë´‰ ë¡œë“œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'hour_history' && Array.isArray(data.candles)) {
      const candles = data.candles;
      const ps = data.period_start ? data.period_start * 1000 : null;
      const pe = data.period_end ? data.period_end * 1000 : null;
      periodIsPast = !!data.is_past;
      if (ps && pe) {
        periodStart = new Date(ps);
        periodEnd   = new Date(pe);
        applyFixedTimeline(periodStart, periodEnd);
      }
      _rangeFixed = false;
      candleData = [];
      lineData   = [];
      candleCount = 0;
      periodOpen = candles.length ? candles[0].open : null;
      lastClose  = candles.length ? candles[candles.length - 1].close : null;

      candles.forEach((c) => {
        const ts = toChartTime((c.time || 0) * 1000);
        candleData.push({ time: ts, open: c.open, high: c.high, low: c.low, close: c.close });
        lineData.push({ time: ts, value: c.close });
      });
      candleCount = candleData.length;
      lastCandleTs = candleData.length ? candleData[candleData.length - 1].time : 0;

      if (viewMode === 'candle') {
        candleSeries.setData(candleData);
        realAreaSeries.setData([]);
      } else {
        realAreaSeries.setData(lineData);
        candleSeries.setData([]);
      }
      anchorSeries.setData([]);
      applyTimeAxisRange();
      document.getElementById('stat-candles').textContent = candleCount;
      document.getElementById('stat-price').textContent = lastClose ? fmt(lastClose) : '--';
      const change = periodOpen ? ((lastClose - periodOpen) / periodOpen * 100) : 0;
      const el = document.getElementById('stat-change');
      el.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(3)}%`;
      el.className = `stat-value ${change >= 0 ? 'up' : 'down'}`;
      return;
    }

    // â”€â”€ prediction_history: ì ‘ì† ì‹œ í•´ë‹¹ 1ì‹œê°„ ì˜ˆì¸¡ íˆìŠ¤í† ë¦¬ ë¡œë“œ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'prediction_history' && Array.isArray(data.predictions)) {
      const colors = ['#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
      data.predictions.forEach((entry, idx) => {
        const preds = entry.predictions || [];
        if (preds.length === 0) return;
        const points = preds.map(p => ({
          time:  toChartTime((p.time || 0) * 1000),
          value: p.value,
          lower: p.lower,
          upper: p.upper,
        }));
        const originTime = toChartTime((entry.origin_time || 0) * 1000);
        const lastCloseVal = entry.last_close;
        const baseColor = colors[idx % colors.length];
        const hasRange = points.some(p => p.lower != null && p.upper != null);

        if (hasRange) {
          const startVal = lastCloseVal ?? points[0]?.value ?? 0;
          const upperSeries = chart.addLineSeries({ color: baseColor + '40', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false });
          const lowerSeries = chart.addLineSeries({ color: baseColor + '40', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted, crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false });
          upperSeries.setData([{ time: originTime, value: startVal }, ...points.map(p => ({ time: p.time, value: p.upper }))]);
          lowerSeries.setData([{ time: originTime, value: startVal }, ...points.map(p => ({ time: p.time, value: p.lower }))]);
          predictionSeriesList.push(upperSeries, lowerSeries);
        }

        const predSeries = chart.addLineSeries({ color: baseColor, lineWidth: 2.5, lineStyle: LightweightCharts.LineStyle.Dashed, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
        if (lastCloseVal != null && points.length > 0) {
          predSeries.setData([{ time: originTime, value: lastCloseVal }, ...points.map(p => ({ time: p.time, value: p.value }))]);
        } else {
          predSeries.setData(points.map(p => ({ time: p.time, value: p.value })));
        }

        predictionSeriesList.push(predSeries);
        lastPredictionEndTs = points[points.length - 1].time;
      });
      document.getElementById('stat-preds').textContent = String(predictionSeriesList.length);
      applyTimeAxisRange();
    }

    // â”€â”€ 1ì‹œê°„ êµ¬ê°„ ê²½ê³„ ì²´í¬ (ì´ë¯¸ ì§€ë‚œ êµ¬ê°„ì´ë©´ ìë™ ìŠ¤ëƒ…ìƒ· ìƒëµ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (!periodIsPast && periodEnd && now >= periodEnd) {
      console.log('â° 1ì‹œê°„ êµ¬ê°„ ì¢…ë£Œ â†’ ìŠ¤ëƒ…ìƒ· + ì´ˆê¸°í™”');
      takeSnapshotAndReset();
      return;
    }

    // â”€â”€ ì‹¤ì‹œê°„ ë¶„ë´‰ ì—…ë°ì´íŠ¸ (ë¶„ë‹¨ìœ„, ë™ì¼ ë¶„ì€ upsert) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'real_time_candle') {
      const c = data.candle;
      const ts = toChartTime((c.time || 0) * 1000);
      const chartCandle = { time: ts, open: c.open, high: c.high, low: c.low, close: c.close };
      const chartLine   = { time: ts, value: c.close };

      // time ê¸°ì¤€ upsert (ë¶„ë‹¨ìœ„ - ë™ì¼ ë¶„ì´ë©´ ë®ì–´ì“°ê¸°)
      let found = false;
      for (let i = 0; i < candleData.length; i++) {
        if (candleData[i].time === ts) {
          candleData[i] = chartCandle;
          lineData[i]   = chartLine;
          found = true;
          break;
        }
      }
      if (!found) {
        candleData.push(chartCandle);
        lineData.push(chartLine);
      }

      if (viewMode === 'candle') {
        candleSeries.update(chartCandle);
      } else {
        realAreaSeries.update(chartLine);
      }

      lastClose = c.close;
      if (periodOpen === null) periodOpen = c.open;

      if (ts !== lastCandleTs) {
        lastCandleTs = ts;
        candleCount = candleData.length;
        document.getElementById('stat-candles').textContent = candleCount;
      }

      // í˜„ì¬ê°€ & êµ¬ê°„ ë³€í™”ìœ¨
      document.getElementById('stat-price').textContent = fmt(c.close);
      const change = periodOpen ? ((c.close - periodOpen) / periodOpen * 100) : 0;
      const el = document.getElementById('stat-change');
      el.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(3)}%`;
      el.className   = `stat-value ${change >= 0 ? 'up' : 'down'}`;

      applyTimeAxisRange();
    }

    // â”€â”€ ì˜ˆì¸¡ ê¶¤ì  + ë³¼ë¦°ì € êµ¬ê°„ (ìƒÂ·í•˜ë‹¨ ë°´ë“œ) â”€â”€â”€â”€â”€â”€â”€
    if (data.type === 'prediction' && Array.isArray(data.predictions) && data.predictions.length > 0) {

      const points = data.predictions.map(p => ({
        time:  toChartTime((p.time || 0) * 1000),
        value: p.value,
        lower: p.lower,
        upper: p.upper,
      }));
      const predEndTs = points[points.length - 1].time;

      const canAdd = predictionSeriesList.length === 0 || lastCandleTs >= lastPredictionEndTs;
      if (!canAdd) return;

      const colors = ['#f59e0b', '#10b981', '#3b82f6', '#8b5cf6', '#ec4899'];
      const baseColor = colors[predictionSeriesList.length % colors.length];
      const originTime = data.origin_time ? toChartTime(data.origin_time * 1000) : points[0].time - 60;

      // êµ¬ê°„ ë°´ë“œ (upper/lower) â€” ìˆìœ¼ë©´ í‘œì‹œ
      const hasRange = points.some(p => p.lower != null && p.upper != null);
      if (hasRange) {
        const upperPoints = [{ time: originTime, value: lastClose }, ...points.map(p => ({ time: p.time, value: p.upper }))];
        const lowerPoints = [{ time: originTime, value: lastClose }, ...points.map(p => ({ time: p.time, value: p.lower }))];
        const bandColor = baseColor + '40';
        const upperSeries = chart.addLineSeries({
          color: bandColor, lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted,
          crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false,
        });
        const lowerSeries = chart.addLineSeries({
          color: bandColor, lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted,
          crosshairMarkerVisible: false, lastValueVisible: false, priceLineVisible: false,
        });
        upperSeries.setData(upperPoints);
        lowerSeries.setData(lowerPoints);
        predictionSeriesList.push(upperSeries, lowerSeries);
      }

      // ë©”ì¸ ì˜ˆì¸¡ì„ 
      const predSeries = chart.addLineSeries({
        color: baseColor, lineWidth: 2.5, lineStyle: LightweightCharts.LineStyle.Dashed,
        crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false,
      });

      if (lastClose != null && points.length > 0) {
        predSeries.setData([{ time: originTime, value: lastClose }, ...points.map(p => ({ time: p.time, value: p.value }))]);
      } else {
        predSeries.setData(points.map(p => ({ time: p.time, value: p.value })));
      }

      predictionSeriesList.push(predSeries);
      lastPredictionEndTs = predEndTs;
      document.getElementById('stat-preds').textContent = String(Math.ceil(predictionSeriesList.length / (hasRange ? 3 : 1)));

      applyTimeAxisRange();
    }
  };
}

connectWS();
</script>
</body>
</html>
